ğŸ”¹ Polymorphism in Java

Polymorphism = â€œMany formsâ€

ğŸ‘‰ Same method name, different behavior, depending on:

parameters (compile time)

object type (runtime)

Java supports polymorphism in two major ways:


1ï¸âƒ£ Compile-Time Polymorphism (Method Overloading)
ğŸ”¹ What it is

When multiple methods have the same name but different parameter lists, and the method call is resolved at compile time.

ğŸ”¹ Rules for Method Overloading

âœ” Same method name
âœ” Different parameter list (number / type / order)

âŒ Cannot overload by:

Return type only

Access modifier only

ğŸ”¹ Why itâ€™s compile-time?

The compiler knows exactly which method to call by looking at arguments.

ğŸ”¹ Real-world use

Utility classes

APIs (e.g., println())

Cleaner, readable code



2ï¸âƒ£ Runtime Polymorphism (Method Overriding)
ğŸ”¹ What it is

When a subclass provides its own implementation of a method already defined in its parent class.




ğŸ”¹ Why Dynamic Method Dispatch is CRUCIAL
âœ… Achieves Runtime Polymorphism
âœ… Enables Loose Coupling
âœ… Used by Spring, Hibernate, JDBC
âœ… Makes code extensible







SOURCE CODE
   â†“
COMPILER
   â”œâ”€ checks method in reference
   â”œâ”€ generates invokevirtual
   â†“
BYTECODE
   â†“
JVM
   â”œâ”€ object type = B
   â”œâ”€ v-table lookup
   â”œâ”€ call B.sound()
